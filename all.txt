/* Monte carlo Mpi */
#include <iostream>
#include <cstdlib>
#include <mpi.h>

#define SEED 3655942

#define ROOT 0

using namespace std;

int main(int argc, char *argv[]) {
	MPI_Init(&argc, &argv);

	int rank, size;
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &size);

	double t;
	if (rank == ROOT) {
		t = MPI_Wtime();
	}

	int n = 10000;
	int count = 0, red_count;
	srand(SEED);
	for (int i = 0; i < n / size; i++) {
		double x = (double)rand() / RAND_MAX;
		double y = (double)rand() / RAND_MAX;
		double z = x*x + y*y;
		if (z <= 1.0) count++;
	}
	MPI_Reduce(&count, &red_count, 1, MPI_INT, MPI_SUM, ROOT, MPI_COMM_WORLD);

	if (rank == ROOT) {
		t = MPI_Wtime() - t;
		cout << "Time: " << t << endl;

		double pi = (double)red_count / n * 4;
		cout << "no. of threads: " << size << endl;
		cout << "no. of trials: " << n << endl;
		cout << "est. of pi: " << pi << endl;
	}

	MPI_Finalize();
}


/* Monte Carlo OPENMP */

#include <iostream>
#include <cstdlib>
#include <omp.h>

#define SEED 3655942

using namespace std;

int main() {
	int th;
	cout << "Enter the number of threads: ";
	cin >> th;
	omp_set_num_threads(th);

	double t = omp_get_wtime();

	int n = 10000;
	int count = 0;
	srand(SEED);
	#pragma omp parallel for reduction(+:count)
	for (int i = 0; i < n; i++) {
		double x = (double)rand() / RAND_MAX;
		double y = (double)rand() / RAND_MAX;
		double z = x*x + y*y;
		if (z <= 1.0) count++;
	}

	t = omp_get_wtime() - t;
	cout << "Time: " << t << endl;

	double pi = (double)count / n * 4;	
	cout << "no. of threads: " << th << endl;
	cout << "no. of trials: " << n << endl;
	cout << "est. of pi: " << pi << endl;
}


/* Matri Multiplication */

#include <iostream>
#include <omp.h>

#define DIM 1000

using namespace std;

int main() {
	int *A = new int[DIM * DIM];
	int *B = new int[DIM * DIM];
	int *C = new int[DIM * DIM];

	double t = omp_get_wtime();

	#pragma omp parallel for // num_threads(1/2/4/8)
	for (int i = 0; i < DIM; i++)
		for (int j = 0; j < DIM; j++)
			for (int k = 0; k < DIM; k++)
				// C[i][k] -> C[DIM*i + k]
				C[DIM*i + k] += A[DIM*i + j] * B[DIM*j + k];

	t = omp_get_wtime() - t;
	cout << "Time: " << t << endl;

	delete[] A;
	delete[] B;
	delete[] C;
}


/* Prime */

#include <iostream>
#include <cmath>
#include <omp.h>

using namespace std;

int strike(bool comp[], int start, int step, int stop) {
	int i; // BEWARE: i should be declared outside loop!
	for(i = start; i <= stop; i += step)
		comp[i] = true;
	return i;
}

int unfriendlySieve(int n) {
	int m = sqrt(n);
	bool* comp = new bool[n+1];

	double t = omp_get_wtime();

	int count = 0;
	for(int i = 2; i <= m; i++) {
		if(!comp[i]) {
			count++;
			strike(comp, 2*i, i, n);
		}
	}
	for(int i = m+1; i <= n; i++) {
		if(!comp[i]) {
			count++;
		}
	}

	t = omp_get_wtime() - t;
	cout << "Time: " << t << endl;

	delete[] comp;
	return count;
}

int friendlySieve(int n) {
	int m = sqrt(n);
	bool* comp = new bool[n+1];

	int *striker = new int[m];
	int *factor = new int[m];
	int fac_cnt = 0;

	double t = omp_get_wtime();

	int count = 0;
	for(int i = 2; i <= m; i++) {
		if(!comp[i]) {
			count++;
			factor[fac_cnt] = i;
			striker[fac_cnt] = strike(comp, 2*i, i, m);
			fac_cnt++;
		}
	}
	for(int left = m+1; left <= n; left += m) {
		int right = min(left+m-1, n);
		for(int k = 0; k < fac_cnt; k++) {
			striker[k] = strike(comp, striker[k], factor[k], right);
		}
		for(int i = left; i <= right; i++) {
			if(!comp[i]) {
				count++;
			}
		}
	}

	t = omp_get_wtime() - t;
	cout << "Time: " << t << endl;

	delete[] striker;
	delete[] factor;
	delete[] comp;
	return count;
}

int parallelySieve(int n) {
	int m = sqrt(n);
	bool* comp = new bool[n+1];

	int *striker = new int[m];
	int *factor = new int[m];
	int fac_cnt = 0;

	double t = omp_get_wtime();

	int count = 0;
	for(int i = 2; i <= m; i++) {
		if(!comp[i]) {
			count++;
			factor[fac_cnt] = i;
			striker[fac_cnt] = strike(comp, 2*i, i, m);
			fac_cnt++;
		}
	}
	for(int left = m+1; left <= n; left += m) {
		int right = min(left+m-1, n);
		#pragma omp parallel for
		for(int k = 0; k < fac_cnt; k++) {
			striker[k] = strike(comp, striker[k], factor[k], right);
		}
		#pragma omp parallel for reduction(+:count)
		for(int i = left; i <= right; i++) {
			if(!comp[i]) {
				count++;
			}
		}
	}

	t = omp_get_wtime() - t;
	cout << "Time: " << t << endl;

	delete[] striker;
	delete[] factor;
	delete[] comp;
	return count;
}

int main() {
	cout << "Unfriendly " << unfriendlySieve(100000000) << endl;
	cout << "Friendly " << friendlySieve(100000000) << endl;
	cout << "Parallely " << parallelySieve(100000000) << endl;
}


/* Image */

#include <iostream>
#include <cstdlib>
#include <gd.h>
#include <omp.h>

using namespace std;

int main(int argc, char *argv[]) {
	if (argc != 3) {
		cout << "Usage: " << argv[0] << " <in.png> <out.png>" << endl;
		exit(1);
	}

	FILE *ifp = fopen(argv[1], "rb");
	FILE *ofp = fopen(argv[2], "wb");

	double t = omp_get_wtime();

	gdImagePtr img = gdImageCreateFromPng(ifp);
	int w = gdImageSX(img);
	int h = gdImageSY(img);

	#pragma omp parallel for // num_threads(1/2/4/8) schedule(static/dynamic/guided)
	for (int x = 0; x < w; x++) {
		for (int y = 0; y < h; y++) {
			int color = gdImageGetPixel(img, x, y);
			int avgColor = (gdImageRed(img, color) + gdImageGreen(img, color) + gdImageBlue(img, color)) / 3;
			color = gdImageColorAllocate(img, avgColor, avgColor, avgColor);
			#pragma omp critical
			gdImageSetPixel(img, x, y, color);
		}
	}

	gdImagePng(img, ofp);
	gdImageDestroy(img);

	fclose(ifp);
	fclose(ofp);

	t = omp_get_wtime() - t;
	cout << "Time: " << t << endl;
}


/*MPI_ Message */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mpi.h>

#define SIZE 4
#define BUFSIZE 32

#define ROOT 0
#define TAG 0

char* m[SIZE] = { "", "Hello", "RVCE", "CSE" };
char msg[BUFSIZE];

int main(int argc, char *argv[]) {
	MPI_Init(&argc, &argv);

	int rank, size;
	MPI_Comm_rank(MPI_COMM_WORLD, &rank);
	MPI_Comm_size(MPI_COMM_WORLD, &size);

	if (size != SIZE) {
		printf("Provide argument: -np %d\n", SIZE);
		exit(1);
	}

	if (rank != ROOT) {
		strcpy(msg, m[rank]);
		MPI_Send(&msg, BUFSIZE, MPI_CHAR, ROOT, TAG, MPI_COMM_WORLD);
	} else {
		for(int i = 0; i < size; i++) {
			if (i == ROOT) continue;
			MPI_Recv(&msg, BUFSIZE, MPI_CHAR, i, TAG, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
			printf("Received %s in process %d from process %d\n", msg, rank, i);
		}
	}

	MPI_Finalize();
}


/* Word Search */

#include <iostream>
#include <fstream>
#include <string>
#include <cctype>
#include <omp.h>

#define SIZE 5
#define FILE "words.txt"

using namespace std;

string words[SIZE] = {"lorem", "ipsum", "dolo", "sit", "amet"};
int counts[SIZE] = {};

void lower(string &str) {
	for (int i = 0; i < str.size(); i++)
		str[i] = tolower(str[i]);
}

int getCount(string fileName, string key) {
	lower(key);
	ifstream file(fileName);
	string word;
	int count = 0;
	while (file >> word) {
		lower(word);
		if(key == word) count++;
	}
	return count;
}

int main() {
	double t = omp_get_wtime();

	#pragma omp parallel for // num_threads(1/2/4/8)
	for (int i = 0; i < SIZE; i++) {
		counts[i] = getCount(FILE, words[i]);
	}

	t = omp_get_wtime() - t;
	cout << "Time: " << t << endl;

	for (int i = 0; i < SIZE; i++) {
		cout << words[i] << " " << counts[i] << endl;
	}
}
